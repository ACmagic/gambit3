
<nav class="navbar navbar-inverse navbar-fixed-top">

    <div class="navbar-header">
        <a href="#" class="navbar-brand">G</a>
    </div>
    <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav">
            <li class="active"><a class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false" href="#"><span class="glyphicon glyphicon-menu-hamburger"></span></a>
                <ul class="dropdown-menu">
                    <li><a href="{{ url('sports/football/nfl') }}">NFL</a></li>
                    <li><a href="{{ url('sports/basketball/nba') }}">NBA</a></li>
                    <li><a href="{{ url('sports/hockey/nhl') }}">NHL</a></li>
                    <li><a href="{{ url('sports/baseball/mlb') }}">MLB</a></li>
                </ul>
            </li>
        </ul>
    </div>

</nav>



------------------------------------------------

npm install xxx --save-dev --no-bin-links

http://perrymitchell.net/article/npm-symlinks-through-vagrant-windows/

bower install PACKAGE --save

Install bower npm package
Install grunt package
install grunt-cli as -global package using -g flag

Install the bower packages
Run grunt to create distribution for asset files.

-------------------------------------------------

Sale / Quote rules

@todo:

Verify that bets can still be placed on predictable (event). If not stop sale.
On the slip page flag every "expired" prediction.

-------------------------------------------------

Add to lines

rolling_inventory = aggregated all time inventory
rolling_amount_min = Max bid amount
rolling_amount_max = Minimum bid amount

realtime_inventory = Number actually available at this time.
realtime_amount_min
realtime_amount_max

These will both be calculated within listeners and adjusted when an advertised line or accepted line is persisted or updated.
This will make all the displays much more optimized vs. attempting to create joins to calculate all these values which
can become incredibly slow and none scalable.

$lineRepository->calculateRollingInventory($line);  SELECT SUM(inventory) FROM advertised_lines WHERE line_id = :lineId
$lineRepository->calculateRollingAmountMin($line);  SELECT MIN(amount_min) FROM advertised_lines WHERE line_id = :lineId
$lineRepository>calculateRollingAmountMax($line);   SELECT MAX(amount_max) FROM advertised_lines WHERE line_id = :lineId

$lineRepository->calculateRealTimeInventory($line); SELECT SUM(al.inventory) - SUM(acl.id) FROM advertised_lines left join accepted_lines WHERE al.line_id = :lineId group by al.line_id
$lineRepostpry->calculateRealTimeAmountMax($line); SELECT MIN(CASE WHEN COUNT(acl.id) <> al.inventory THAN al.amount_min ELSE NULL END) FROM advertised_lines left join accepted_lines WHERE al.line_id = lineId group by al.line_id
$lineRepository->calculateRealTimeAmountMin($line);

$line->setRollingInventory($x);
$line->setRollingAmountMax($y);
$line->setRollingAmountMin($z);

...

EntityManager::persist($line); -- the event will need to happen post persist and update -- otherwise the values won't be available to recalculate.
EntityManager::flush();


SELECT
     COALESCE(MIN(ad.amount),0)
  FROM
     advertised_lines ad
 INNER
  JOIN
    (SELECT
         ad.id advertised_line_id,
         ad.inventory - COUNT(ac.id) realtime_inventory
      FROM
         advertised_lines ad
      LEFT OUTER
      JOIN
         accepted_lines ac
        ON
          ad.id = ac.advertised_line_id
     GROUP
        BY
         ad.id
    HAVING
         realtime_inventory > 0) av
   ON
      ad.id = av.advertised_line_id


      SELECT ad.id advertised_line_id, ad.inventory - COUNT(ac.id) realtime_inventory FROM Modules\Catalog\Entities\AdvertisedLine ad LEFT JOIN ad.acceptedLines ac WHERE ad.line = :line GROUP BY ad.id HAVING realtime_inventory > 0




SELECT COALESCE(MIN(ad.amount),0) as val FROM Modules\Catalog\Entities\AdvertisedLine ad INNER JOIN SELECT ad.id advertised_line_id,ad.inventory - COUNT(ac.id) realtime_inventory FROM Modules\Catalog\Entities\AdvertisedLine ad LEFT JOIN ad.acceptedLines ac WHERE ad.line = :line GROUP BY ad.id HAVING realtime_inventory > 0 av ON ad.id = av.advertised_line_id


SELECT
     COALESCE(MIN(ad.amount),0) val
  FROM
     advertised_lines ad
 INNER
  JOIN
    (SELECT
         ad.id advertised_line_id,
         ad.inventory - COUNT(ac.id) realtime_inventory
      FROM
         advertised_lines ad
      LEFT OUTER
      JOIN
         accepted_lines ac
        ON
          ad.id = ac.advertised_line_id
     WHERE
          ad.id = :lineId
     GROUP
        BY
         ad.id
    HAVING
         realtime_inventory > 0) av
   ON
      ad.id = av.advertised_line_id

-------------------------------------------------

json matching notes

select  * from sale_advertised_lines WHERE JSON_CONTAINS(predictions_cache,'{"type":"Modules\\\\Sales\\\\Entities\\\\SalePointSpread","spread": 4,"game_id": 10,"pick_id": 240}','$[0]','$[1]','$[2]','$[3]');
select * from sale_advertised_lines;

The trick: >= 5.7.9

select  * from sale_advertised_lines WHERE JSON_CONTAINS(predictions_cache->'$[*]','{"type":"Modules\\\\Sales\\\\Entities\\\\SalePointSpread","spread": 10,"game_id": 5,"pick_id":28}');

The syslogic JSON_* functions don't support the -> syntax... errors out. Figure out a wrok around or need to fork and add to library. I prefer not to fork.

select  * from sale_advertised_lines WHERE JSON_CONTAINS(predictions_cache,'{"type": "Modules\\\\Sales\\\\Entities\\\\SalePointSpread", "spread": 5, "game_id": 1, "pick_id": 11}','$[*]');


Try to slightly change what it looks like...

select  * from sale_advertised_lines WHERE JSON_CONTAINS(predictions_cache->'$[*]','{"type": "Modules\\Sales\\Entities\\SalePointSpread", "spread": 5, "game_id": 1, "pick_id": 11}');

Using json contains path

select  * from sale_advertised_lines WHERE JSON_CONTAINS_PATH('{"type": "Modules\\\\Sales\\\\Entities\\\\SalePointSpread", "spread": 5, "game_id": 1, "pick_id": 11}','one','@predictions_cache[0]');

--------------------------------------------------
Payouts

advertised_line_payouts
- posting_id (pk)
- advertised_line_id

accepted_line_payouts
- posting_id (pk)
- accepted_line_id

--------------------------------------------------

MySQL >= 5.7.8

Project requires MySQL w/ JSON support.

Must install PHP manually since no way to this in puphpet exists yet. Puphpet
gives you a very old version of 5.7 that does not include json support.

https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-ubuntu-14-04

-- doctrine/dbal was forked to add json support for mysql versions >= 5.7.8. Hopefully
doctrine master will add support in the future.

---------------------------------------------------

Recipe: Tear down and up the db

php artisan doctrine:migrations:refresh
php artisan gambit:core:seed

--------------------------------------------------

Recipe for migrations

execute new migrations:
php artisan doctrine:migrations:migrate

generate new stub:
php artisan doctrine:migrations:generate

--------------------------------------------------

command line xdebug

export PHP_IDE_CONFIG="serverName=local.gambit"
export XDEBUG_CONFIG="idekey=PHPStorm"

---------------------------------------------------

redis

Command to start redis server:

redis-server

---------------------------------------------------

seeker
house

----------------------------------------------------

Install dataset
test dataset

----------------------------------------------------

Buy credits


-----------------------------------------------------


$items = $quote->getItems();



$prediction = PredictionFactory::makePrediction($postData);


Cart::addPrediction($prediction);



cart/add/prediction  []


cart/add/line []

----------------------------------------------------------

ISSUES:

Allowed to purchase more lines than available.
Odds calculations need to be added and costs adjusted taking into consideration sides


---------------------------------------------------------

Catalog architecture

Each category will have an implicit landing page. There will be a default
landing page layout while also allowing complete overrides for specific cases.

Ex.

http://local.kyle/sports/football/nfl

Would take you to the nfl landing page. Perhaps at the top there is a slider
of the open events and/or common lines. Than at the bottom an aggregated
views. Perhaps we make individual components/widgets that can be added to any
page.

We could create a url_alias table that would map a path like:

/sports/football/nfl => a specific controller and inject the params, like the category ID. This
might be the best way to support overriding specific paths.

Would URL alias be global, store, or website specific?

Would it be best to do:

url_alias
- globals -- apply to all stores

url_alias_store
-- overrides per store ??

or is that making things to complex?

-- Create an event that whenever a category is created the associated url_alias is created?

For now a simple url_alias table will probably work.
-----------------------
id
url ie. sports/football/nfl
route:    ie. -- Full path to route --

What about the dynamic/implicit routes like:

sports/football/nfl/{event}/lines

How do we handle those??