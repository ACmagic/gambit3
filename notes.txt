npm install xxx --save-dev --no-bin-links

http://perrymitchell.net/article/npm-symlinks-through-vagrant-windows/

bower install PACKAGE --save

-------------------------------------------------

Add to lines

rolling_inventory = aggregated all time inventory
rolling_amount_min = Max bid amount
rolling_amount_max = Minimum bid amount

realtime_inventory = Number actually available at this time.
realtime_amount_min
realtime_amount_max

These will both be calculated within listeners and adjusted when an advertised line or accepted line is persisted or updated.
This will make all the displays much more optimized vs. attempting to create joins to calculate all these values which
can become incredibly slow and none scalable.

$lineRepository->calculateRollingInventory($line);  SELECT SUM(inventory) FROM advertised_lines WHERE line_id = :lineId
$lineRepository->calculateRollingAmountMin($line);  SELECT MIN(amount_min) FROM advertised_lines WHERE line_id = :lineId
$lineRepository>calculateRollingAmountMax($line);   SELECT MAX(amount_max) FROM advertised_lines WHERE line_id = :lineId

$lineRepository->calculateRealTimeInventory($line); SELECT SUM(al.inventory) - SUM(acl.id) FROM advertised_lines left join accepted_lines WHERE al.line_id = :lineId group by al.line_id
$lineRepostpry->calculateRealTimeAmountMax($line); SELECT MIN(CASE WHEN COUNT(acl.id) <> al.inventory THAN al.amount_min ELSE NULL END) FROM advertised_lines left join accepted_lines WHERE al.line_id = lineId group by al.line_id
$lineRepository->calculateRealTimeAmountMin($line);

$line->setRollingInventory($x);
$line->setRollingAmountMax($y);
$line->setRollingAmountMin($z);

...

EntityManager::persist($line); -- the event will need to happen post persist and update -- otherwise the values won't be available to recalculate.
EntityManager::flush();


SELECT
     COALESCE(MIN(ad.amount),0)
  FROM
     advertised_lines ad
 INNER
  JOIN
    (SELECT
         ad.id advertised_line_id,
         ad.inventory - COUNT(ac.id) realtime_inventory
      FROM
         advertised_lines ad
      LEFT OUTER
      JOIN
         accepted_lines ac
        ON
          ad.id = ac.advertised_line_id
     GROUP
        BY
         ad.id
    HAVING
         realtime_inventory > 0) av
   ON
      ad.id = av.advertised_line_id


      SELECT ad.id advertised_line_id, ad.inventory - COUNT(ac.id) realtime_inventory FROM Modules\Catalog\Entities\AdvertisedLine ad LEFT JOIN ad.acceptedLines ac WHERE ad.line = :line GROUP BY ad.id HAVING realtime_inventory > 0




SELECT COALESCE(MIN(ad.amount),0) as val FROM Modules\Catalog\Entities\AdvertisedLine ad INNER JOIN SELECT ad.id advertised_line_id,ad.inventory - COUNT(ac.id) realtime_inventory FROM Modules\Catalog\Entities\AdvertisedLine ad LEFT JOIN ad.acceptedLines ac WHERE ad.line = :line GROUP BY ad.id HAVING realtime_inventory > 0 av ON ad.id = av.advertised_line_id


SELECT
     COALESCE(MIN(ad.amount),0) val
  FROM
     advertised_lines ad
 INNER
  JOIN
    (SELECT
         ad.id advertised_line_id,
         ad.inventory - COUNT(ac.id) realtime_inventory
      FROM
         advertised_lines ad
      LEFT OUTER
      JOIN
         accepted_lines ac
        ON
          ad.id = ac.advertised_line_id
     WHERE
          ad.id = :lineId
     GROUP
        BY
         ad.id
    HAVING
         realtime_inventory > 0) av
   ON
      ad.id = av.advertised_line_id

-------------------------------------------------

json matching notes

select  * from sale_advertised_lines WHERE JSON_CONTAINS(predictions_cache,'{"type":"Modules\\\\Sales\\\\Entities\\\\SalePointSpread","spread": 4,"game_id": 10,"pick_id": 240}','$[0]','$[1]','$[2]','$[3]');
select * from sale_advertised_lines;

The trick: >= 5.7.9

select  * from sale_advertised_lines WHERE JSON_CONTAINS(predictions_cache->'$[*]','{"type":"Modules\\\\Sales\\\\Entities\\\\SalePointSpread","spread": 10,"game_id": 5,"pick_id":28}');

The syslogic JSON_* functions don't support the -> syntax... errors out. Figure out a wrok around or need to fork and add to library. I prefer not to fork.

select  * from sale_advertised_lines WHERE JSON_CONTAINS(predictions_cache,'{"type": "Modules\\\\Sales\\\\Entities\\\\SalePointSpread", "spread": 5, "game_id": 1, "pick_id": 11}','$[*]');


Try to slightly change what it looks like...

select  * from sale_advertised_lines WHERE JSON_CONTAINS(predictions_cache->'$[*]','{"type": "Modules\\Sales\\Entities\\SalePointSpread", "spread": 5, "game_id": 1, "pick_id": 11}');

Using json contains path

select  * from sale_advertised_lines WHERE JSON_CONTAINS_PATH('{"type": "Modules\\\\Sales\\\\Entities\\\\SalePointSpread", "spread": 5, "game_id": 1, "pick_id": 11}','one','@predictions_cache[0]');

--------------------------------------------------

MySQL >= 5.7.8

Project requires MySQL w/ JSON support.

Must install PHP manually since no way to this in puphpet exists yet. Puphpet
gives you a very old version of 5.7 that does not include json support.

https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-ubuntu-14-04

-- doctrine/dbal was forked to add json support for mysql versions >= 5.7.8. Hopefully
doctrine master will add support in the future.

---------------------------------------------------

Recipe: Tear down and up the db

php artisan doctrine:migrations:refresh
php artisan gambit:core:seed

--------------------------------------------------

Recipe for migrations

execute new migrations:
php artisan doctrine:migrations:migrate

generate new stub:
php artisan doctrine:migrations:generate

--------------------------------------------------

command line xdebug

export PHP_IDE_CONFIG="serverName=local.kyle"
export XDEBUG_CONFIG="idekey=PHPStorm"

---------------------------------------------------

redis

Command to start redis server:

redis-server

---------------------------------------------------

seeker
house

----------------------------------------------------

Install dataset
test dataset

----------------------------------------------------

Buy credits


-----------------------------------------------------


$items = $quote->getItems();



$prediction = PredictionFactory::makePrediction($postData);


Cart::addPrediction($prediction);



cart/add/prediction  []


cart/add/line []

----------------------------------------------------------

ISSUES:

Allowed to purchase more lines than available.
Odds calculations need to be added and costs adjusted taking into consideration sides